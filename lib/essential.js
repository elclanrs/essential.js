// Generated by CoffeeScript 1.10.0

/*
 * Essential.js 1.1.20
 * @author Cedric Ruiz
 * @license MIT
 */

(function() {
  var K, _, add, all, any, ap, append, apply, applyNew, binary, bindAll, builtin, chain, combinations, compose, concat, countBy, createEventStream, curry, deepClone, deepExtend, deepPluck, deepWhere, drop, dups, each, either, eq, extend, filter, first, flatMap, flatten, flip, flip3, fmap, fold, fold1, foldr, foldr1, forOwn, format, gmatch, groupBy, id, inArray, indexOf, initial, intercalate, interleave, intersection, intersperse, isType, last, liftA, map, mapAsync, mapKeys, mul, nary, ncurry, nflip, notEq, notF, over, pairs, partial, pcompose, permutations, pipe, pluck, powerset, psequence, range, remove, rest, seq, seqM, sequence, shuffle, slice, sortBy, sub, tails, take, template, toArray, toObject, typeOf, unary, union, unique, uniqueBy, unzipObject, values, variadic, where, zip, zipObject, zipWith, λ,
    slice1 = [].slice,
    hasProp = {}.hasOwnProperty,
    indexOf1 = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = {};

  id = function(x) {
    return x;
  };

  K = function(x) {
    return function() {
      return x;
    };
  };

  builtin = id.bind.bind(id.call);

  toArray = builtin(Array.prototype.slice);

  variadic = function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return as;
  };

  ncurry = function(n, f, as) {
    if (as == null) {
      as = [];
    }
    return function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      bs = as.concat(bs);
      if (bs.length < n) {
        return ncurry(n, f, bs);
      } else {
        return f.apply(null, bs);
      }
    };
  };

  λ = curry = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (f.length > as.length) {
        return ncurry(f.length, f, as);
      } else {
        return f.apply(null, as);
      }
    };
  };

  apply = λ(function(f, as) {
    return f.apply(null, as);
  });

  applyNew = λ(function(f, as) {
    return new (f.bind.apply(f, [null].concat(slice1.call(as))));
  });

  partial = function() {
    var as, f;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    return function() {
      var args, bs, i;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      args = as.concat(bs);
      i = args.length;
      while (i--) {
        if (args[i] === _) {
          args[i] = args.splice(-1)[0];
        }
      }
      return f.apply(null, args);
    };
  };

  flip = λ(function(f, x, y) {
    return f(y, x);
  });

  flip3 = λ(function(f, x, y, z) {
    return f(z, y, x);
  });

  nflip = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.reverse());
    };
  };

  unary = λ(function(f, x) {
    return f(x);
  });

  binary = λ(function(f, x, y) {
    return f(x, y);
  });

  nary = λ(function(n, f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.slice(0, n));
    };
  });

  compose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fs.reduce(function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    });
  };

  pcompose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function(xs) {
      return xs.map(function(x, i) {
        return typeof fs[i] === "function" ? fs[i](x) : void 0;
      });
    };
  };

  pipe = seq = sequence = nflip(compose);

  psequence = nflip(pcompose);

  over = λ(function(f, g, x, y) {
    return f(g(x), g(y));
  });

  notF = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return !f.apply(null, as);
    };
  };

  eq = λ(function(x, y) {
    return y === x;
  });

  notEq = λ(function(x, y) {
    return y !== x;
  });

  typeOf = function(x) {
    return Object.prototype.toString.call(x).slice(8, -1);
  };

  isType = λ(function(t, x) {
    return typeOf(x) === t;
  });

  toObject = function(xs) {
    return xs.reduce(function(acc, x, i) {
      if (i % 2) {
        acc[xs[i - 1]] = x;
      }
      return acc;
    }, {});
  };

  extend = function() {
    var a, b, bs, k, l, len, v;
    a = arguments[0], bs = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (l = 0, len = bs.length; l < len; l++) {
      b = bs[l];
      for (k in b) {
        if (!hasProp.call(b, k)) continue;
        v = b[k];
        a[k] = v;
      }
    }
    return a;
  };

  deepExtend = function() {
    var a, b, bs, k, l, len, v;
    a = arguments[0], bs = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (l = 0, len = bs.length; l < len; l++) {
      b = bs[l];
      for (k in b) {
        if (!hasProp.call(b, k)) continue;
        v = b[k];
        a[k] = typeof v === 'object' ? deepExtend(a[k], v) : v;
      }
    }
    return a;
  };

  deepClone = function(obj) {
    var init;
    init = isType('Array', obj) ? [] : {};
    return Object.keys(obj).reduce(function(acc, k) {
      var mustClone, x;
      x = obj[k];
      mustClone = isType('Array', x) || isType('Object', x);
      acc[k] = mustClone ? deepClone(x) : x;
      return acc;
    }, init);
  };

  forOwn = λ(function(acc, f, obj) {
    Object.keys(obj).forEach(function(k, i) {
      return acc = f(acc, k, obj[k], i);
    });
    return acc;
  });

  fold = flip3(builtin(Array.prototype.reduce));

  fold1 = λ(function(f, xs) {
    return fold(xs[0], f, xs);
  });

  foldr = flip3(builtin(Array.prototype.reduceRight));

  foldr1 = λ(function(f, xs) {
    return foldr(xs[0], f, xs);
  });

  map = ncurry(2, function() {
    var input, obj, result;
    obj = false;
    input = (isType('Object', arguments[1]) ? (obj = unzipObject(arguments[1]))[1] : arguments[1]);
    result = input.map(arguments[0]);
    return (obj ? zipObject(obj[0], result) : result);
  });

  mapKeys = function(obj, f) {
    return zipObject(map(arguments[0], Object.keys(arguments[1])), unzipObject(arguments[1])[1]);
  };

  filter = ncurry(2, function() {
    var input, obj, result;
    obj = false;
    input = (isType('Object', arguments[1]) ? (obj = unzipObject(arguments[1]))[1] : arguments[1]);
    result = input.filter(arguments[0]);
    return (obj ? zipObject(obj[0], result) : result);
  });

  any = flip(builtin(Array.prototype.some));

  all = flip(builtin(Array.prototype.every));

  each = flip(builtin(Array.prototype.forEach));

  indexOf = flip(builtin(Array.prototype.indexOf));

  concat = builtin(Array.prototype.concat);

  slice = λ(function(i, j, xs) {
    if (j != null) {
      return xs.slice(i, j);
    } else {
      return xs.slice(i);
    }
  });

  first = function(arg) {
    var x, xs;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    return x;
  };

  last = function(arg) {
    var l, x, xs;
    xs = 2 <= arg.length ? slice1.call(arg, 0, l = arg.length - 1) : (l = 0, []), x = arg[l++];
    return x;
  };

  rest = slice(1, null);

  initial = slice(0, -1);

  take = slice(0);

  drop = partial(slice, _, null, _);

  inArray = λ(function(xs, x) {
    return indexOf1.call(xs, x) >= 0;
  });

  remove = λ(function(x, xs) {
    var ys;
    ys = xs.slice(0);
    ys.splice(xs.indexOf(x), 1);
    return ys;
  });

  tails = function(xs) {
    return xs.map(function(x, i) {
      return xs.slice(i);
    });
  };

  uniqueBy = λ(function(f, xs) {
    var seen;
    seen = [];
    return xs.filter(function(x) {
      var fx;
      fx = f(x);
      if (indexOf1.call(seen, fx) >= 0) {
        return;
      }
      seen.push(fx);
      return true;
    });
  });

  unique = uniqueBy(id);

  dups = function(xs) {
    return xs.filter(function(x, i) {
      return xs.indexOf(x) !== i;
    });
  };

  flatten = function(xs) {
    var ref;
    while (xs.some(Array.isArray)) {
      xs = (ref = Array.prototype).concat.apply(ref, xs);
    }
    return xs;
  };

  union = compose(unique, flatten, variadic);

  intersection = compose(unique, dups, flatten, variadic);

  flatMap = λ(function(xs, f) {
    return xs.reduce(function(acc, x) {
      return acc.concat(f(x));
    }, []);
  });

  pluck = λ(function(x, xs) {
    return String(x).split('.').reduce(function(acc, x) {
      if (acc == null) {
        return;
      }
      return acc[x];
    }, xs);
  });

  deepPluck = λ(function(x, xs) {
    var out;
    out = [];
    while (xs = pluck(x, xs)) {
      out.push(xs);
    }
    return out;
  });

  where = λ(function(obj, xs) {
    return xs.filter(function(x) {
      return Object.keys(obj).every(function(k) {
        return obj[k] === x[k];
      });
    });
  });

  deepWhere = λ(function(match, xs) {
    var find;
    find = λ(function(match, obj) {
      return Object.keys(obj).every(function(k) {
        var mustFind;
        mustFind = [obj[k], match[k]].every(function(x) {
          return isType('Object', x || isType('Array', x));
        });
        if (mustFind) {
          return find(match[k], obj[k]);
        }
        return match[k] === obj[k];
      });
    });
    return xs.filter(find(match));
  });

  values = function(obj) {
    var results, v;
    results = [];
    for (_ in obj) {
      if (!hasProp.call(obj, _)) continue;
      v = obj[_];
      results.push(v);
    }
    return results;
  };

  pairs = forOwn([], function(acc, k, v) {
    return acc.concat([[k, v]]);
  });

  interleave = λ(function(arg, ys) {
    var x, xs;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    if (x == null) {
      return ys;
    }
    return [x].concat(interleave(ys, xs));
  });

  intersperse = λ(function(x, xs) {
    var i, l, len, out, ref, y;
    out = [xs[0]];
    ref = xs.slice(1);
    for (i = l = 0, len = ref.length; l < len; i = ++l) {
      y = ref[i];
      out.push(x, y);
    }
    return out;
  });

  intercalate = compose(flatten, intersperse);

  zip = function() {
    var xss;
    xss = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return xss[0].map(function(_, i) {
      return xss.map(pluck(i));
    });
  };

  zipWith = function() {
    var f, xss;
    f = arguments[0], xss = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    return apply(zip, xss).map(partial(apply, f));
  };

  zipObject = compose(toObject, flatten, zip);

  unzipObject = forOwn([[], []], function(acc, k, v, i) {
    acc[0][i] = k;
    acc[1][i] = v;
    return acc;
  });

  range = λ(function(m, n) {
    var l, results;
    return (function() {
      results = [];
      for (var l = m; m <= n ? l <= n : l >= n; m <= n ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this);
  });

  shuffle = function(xs) {
    var i, j, l, len, ref, ys;
    ys = xs.slice(0);
    for (i = l = 0, len = ys.length; l < len; i = ++l) {
      _ = ys[i];
      j = Math.random() * (i + 1) | 0;
      ref = [ys[j], ys[i]], ys[i] = ref[0], ys[j] = ref[1];
    }
    return ys;
  };

  sortBy = λ(function(f, xs) {
    return xs.sort(function(x, y) {
      var fx, fy;
      fx = f(x);
      fy = f(y);
      switch (false) {
        case !(fx > fy):
          return 1;
        case !(fx < fy):
          return -1;
        default:
          return 0;
      }
    });
  });

  groupBy = λ(function(f, xs) {
    return xs.reduce(function(acc, x) {
      var fx;
      fx = f(x);
      acc[fx] = (acc[fx] || []).concat([x]);
      return acc;
    }, {});
  });

  countBy = sequence(groupBy, forOwn({}, function(acc, k, v) {
    acc[k] = v.length;
    return acc;
  }));

  format = λ(function(xs, x) {
    return x.replace(/%(\d+)/g, function(_, i) {
      return xs[--i] || '';
    });
  });

  template = λ(function(obj, x) {
    return x.replace(/#\{(.+?)\}/g, function(_, k) {
      return obj[k] || '';
    });
  });

  gmatch = λ(function(re, x) {
    var out;
    out = [];
    x.replace(re, function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return out.push.apply(out, as.slice(1, -2));
    });
    return out;
  });

  permutations = function(xs) {
    var l, len, len1, o, out, ref, x, ys;
    if (!xs.length) {
      return [[]];
    }
    out = [];
    for (l = 0, len = xs.length; l < len; l++) {
      x = xs[l];
      ref = permutations(remove(x, xs));
      for (o = 0, len1 = ref.length; o < len1; o++) {
        ys = ref[o];
        out.push([x].concat(ys));
      }
    }
    return out;
  };

  combinations = function(xs) {
    var combine, l, ref, results;
    combine = function(n, xs) {
      if (n === 0) {
        return [[]];
      }
      return flatMap(tails(xs), function(arg) {
        var xs_, y;
        y = arg[0], xs_ = 2 <= arg.length ? slice1.call(arg, 1) : [];
        return combine(n - 1, xs_).map(function(ys) {
          return [y].concat(slice1.call(ys));
        });
      });
    };
    return flatMap((function() {
      results = [];
      for (var l = 1, ref = xs.length; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this), function(n) {
      return combine(n, xs);
    });
  };

  powerset = function(arg) {
    var x, xs, xss;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    if (x == null) {
      return [[]];
    }
    xss = powerset(xs);
    return interleave(xss, xss.map(binary(concat, [x])));
  };

  fmap = λ(function(f, ma) {
    return ma.map(f);
  });

  ap = λ(function(mf, ma) {
    return ma.ap(mf);
  });

  chain = λ(function(f, ma) {
    return ma.chain(f);
  });

  liftA = λ(function(ctor, f, ms) {
    return ms.reduce(function(acc, ma) {
      return acc.ap(ma);
    }, ctor.of(f));
  });

  seqM = λ(function(ctor, ms) {
    return ms.reduceRight(function(ma, mb) {
      return ma.chain(function(a) {
        return mb.map(function(b) {
          return [b].concat(a);
        });
      });
    }, ctor.of([]));
  });

  add = λ(function(x, y) {
    return x + y;
  });

  mul = λ(function(x, y) {
    return x * y;
  });

  sub = λ(function(x, y) {
    return x - y;
  });

  append = function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return as.reduce(add);
  };

  either = curry(function(a, b, data) {
    return a(data) || b(data);
  });

  bindAll = function(obj, scope) {
    if (scope == null) {
      scope = obj;
    }
    return forOwn(obj, function(k, v) {
      if (typeof v === "function") {
        return obj[k] = v.bind(scope);
      }
    });
  };

  mapAsync = function(arr, done, cb) {
    if( !arr || arr.length == 0 ) done() 
    var f, funcs, i, k, v;
    funcs = [];
    i = 0;
    for (k in arr) {
      v = arr[k];
      f = function(i, v) {
        return function() {
          var e, error;
          try {
            if (funcs[i + 1] != null) {
              return cb(v, i, funcs[i + 1]);
            } else {
              return cb(v, i, done);
            }
          } catch (error) {
            e = error;
            return done(new Error(e));
          }
        };
      };
      funcs.push(f(i++, v));
    }
    return funcs[0]();
  };

  createEventStream = function(selector, event) {
    return function(next) {
      var element, elements, l, len, results;
      if (selector[0] === "#") {
        element = document.querySelector(selector);
        if (element) {
          return element.addEventListener(event, next);
        }
      } else {
        elements = document.querySelectorAll(selector);
        results = [];
        for (l = 0, len = elements.length; l < len; l++) {
          element = elements[l];
          results.push(element.addEventListener(event, next));
        }
        return results;
      }
    };
  };

  module.exports = {
    _: _,
    id: id,
    K: K,
    builtin: builtin,
    toArray: toArray,
    mapAsync: mapAsync,
    createEventStream: createEventStream,
    variadic: variadic,
    apply: apply,
    applyNew: applyNew,
    ncurry: ncurry,
    λ: λ,
    curry: curry,
    partial: partial,
    flip: flip,
    flip3: flip3,
    nflip: nflip,
    unary: unary,
    binary: binary,
    nary: nary,
    compose: compose,
    pcompose: pcompose,
    sequence: sequence,
    seq: seq,
    pipe: pipe,
    over: over,
    notF: notF,
    not: notF,
    eq: eq,
    notEq: notEq,
    typeOf: typeOf,
    isType: isType,
    toObject: toObject,
    extend: extend,
    deepExtend: deepExtend,
    deepClone: deepClone,
    forOwn: forOwn,
    fold: fold,
    fold1: fold1,
    foldr: foldr,
    foldr1: foldr1,
    map: map,
    mapKeys: mapKeys,
    filter: filter,
    any: any,
    all: all,
    each: each,
    indexOf: indexOf,
    concat: concat,
    slice: slice,
    first: first,
    last: last,
    rest: rest,
    initial: initial,
    take: take,
    drop: drop,
    inArray: inArray,
    remove: remove,
    tails: tails,
    uniqueBy: uniqueBy,
    unique: unique,
    dups: dups,
    flatten: flatten,
    union: union,
    intersection: intersection,
    flatMap: flatMap,
    pluck: pluck,
    deepPluck: deepPluck,
    where: where,
    deepWhere: deepWhere,
    values: values,
    pairs: pairs,
    interleave: interleave,
    intersperse: intersperse,
    intercalate: intercalate,
    zip: zip,
    zipWith: zipWith,
    zipObject: zipObject,
    unzipObject: unzipObject,
    range: range,
    shuffle: shuffle,
    sortBy: sortBy,
    groupBy: groupBy,
    countBy: countBy,
    format: format,
    template: template,
    gmatch: gmatch,
    permutations: permutations,
    combinations: combinations,
    powerset: powerset,
    bindAll: bindAll,
    add: add,
    mul: mul,
    sub: sub,
    append: append,
    either: either,
    fmap: fmap,
    ap: ap,
    chain: chain,
    liftA: liftA,
    seqM: seqM
  };

  module.exports.expose = partial(extend, _, module.exports);

  module.exports.local = (function() {
    var code;
    code = function() {
      var k, str, v;
      str = 'var ejs = require("essentialjs")';
      for (k in this) {
        v = this[k];
        if (k !== '_') {
          str += " ;" + k + " = ejs." + k;
        }
      }
      return str + ";";
    };
    code.apply(this);
    return new Function('require', code.apply(this));
  }).bind(module.exports);

}).call(this);
